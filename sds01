/*
[시간 제한]
C++ : 55개의 테스트 케이스를 합쳐 1초

[메모리제한]

C++ : 512MB

[문제]
한창 색깔에 심취해 있는 우정이는 색종이를 가지고 색깔놀이를 하고 있었다. 우정이는 색종이를 색깔별로 한 줄로 늘어 놓아, 같은 색깔의 색종이가 각각 몇 장인지를 알아보기로 했다.

그림1

[그림1]
위의 [그림1]과 같이 같은 색상의 색종이를 한데 모으면 색상별로 몇 장이 되는지를 쉽게 알 수 있을 것이다.

우정이가 이렇게 색종이를 색깔별로 분류한 다음 잠시 화장실에 간 동안, 동생 다정이는 우정이가 분류한 색종이를 보다가 그만 손에 들고 있던 물컵을 떨어뜨렸고, 일부 색종이에 물이 튀어 젖고 말았다. 마침 옆에 있던 엄마는 급히 쏟아진 물을 닦은 후 젖어버린 색종이를 골라 치워버렸는데, 이때 화장실에서 돌아온 우정이는 자신이 분류한 색종이의 일부가 없어진 것을 보고 마음이 상했지만, 그래도 현재 남아있는 색종이 만으로 다정이가 물을 쏟기 전 무슨 색의 색종이가 가장 많이 있었는지를 유추해 보기로 했다.

다정이가 물을 쏟기 전, 우정이가 색종이를 위의 [그림1]과 같이 분류했을 때, 가장 왼쪽에 있는 색깔을 1번 색으로 하고, 왼쪽부터 차례대로 색깔별로 번호를 하나씩 증가하여 매겼다. 위의 [그림1]을 예로 들면, 우정이는 총 9장의 색종이를 가지고 있었고, 색깔의 종류는 3가지였으며, 왼쪽부터 색깔별로 번호를 매기면, 빨강색은 1번, 노랑색은 2번, 보라색은 3번으로 매겨졌을 것이다. 그러면, [그림 2]와 같이 도식화할 수 있다.

그림2

[그림2]
그리고, 물에 젖어 색종이가 버려진 칸을 0 으로 표시한다면, 물에 젖은 색종이가 무엇이냐에 따라 아래와 같은 경우가 생길 수 있을 것이다. 아래 그림들([그림 3])은 물에 젖어 버려진 색종이들이 발생한 여러 경우들 중 일부를 예를 들어 표현한 것이다.

그림3

[그림3]
이와 같이 젖은 색종이가 버려진 이후의 상태가 주어졌을 때, 물을 쏟기 전 가장 많은 색깔의 색종이가 최대 몇 장이 있었을지를 유추하는 프로그램을 작성하라.

[제한 조건]
우정이가 원래 갖고 있던 색종이의 개수 : N
우정이가 원래 갖고 있던 색종이 색깔의 종류수 : K

라고 할 때 50개의 입력에 대한 제한 조건은 다음과 같다.

1 ≤ N ≤ 10000
1 ≤ K ≤ N
우정이는 갖고 있던 색종이를 모두 사용하여 색깔별로 분류하였으며, 다정이가 물을 쏟은 뒤에도 색종이들의 순서는 뒤바뀌지 않았다.
[입력]
첫 줄에 테스트케이스 T 가 주어지고, 그 다음 줄부터 T개의 테스트 케이스 가 주어진다. 각 케이스는 두 줄로 구성되어 있으며, 첫 줄에는 N 과 K 가 공백으로 구분되어 차례대로 주어지고, 두 번째 줄에는 물에 젖어 일부의 색종이가 버려진 상태에서의 N 개의 색종이의 색깔 번호(빈 칸일 경우 0)가 왼쪽부터 차례대로 공백으로 구분되어 주어진다.

[출력]
총 T 줄이 출력된다. 각 줄은 #x로 시작하고 (x는 테스트 케이스 번호, 1부터 시작) 공백을 하나 둔 후 유추가 가능한 가장 많은 색깔의 색종이의 최대 장수를 출력한다.

[입출력 예]

5 
9 3 
1 1 2 2 2 2 3 3 3 
9 3 
1 1 2 0 0 2 3 3 3 
9 3 
0 1 2 2 0 0 3 0 0 
9 3 
0 0 0 0 0 0 0 0 0 
10 4 
0 0 2 0 0 0 0 0 4 0 

(출력)

#1 4 
#2 4 
#3 5 
#4 7 
#5 6 

*/


#include <iostream>
#include <cstring>
#include <stack>
#include <algorithm>
using namespace std;
const int MAX=10001;
int a[MAX]={0,};
int n,k;
int get_cnt(int number)
{
    int cnt=0;
    int flag=0;
    for(int i=0;i<n;i++)
    {
        if(a[i]==number)
        {
            flag=i;
            break;
        }
       
    }
    
    for(int i=flag;i<n;i++)
        {
            if(a[i]==0)
             {   cnt++;
             }
            if(a[i]==number)
                cnt++;
            if(a[i]==number+1)
                break;
            if(a[i]> number+1)
            {
                int x=a[i]-number-1;
                
                cnt=cnt-x;
                break;
            }
        }
    
    for(int i=flag-1;i>=0;i--)
    {
        
        if(a[i]==number)
            cnt++;
        if(a[i]+1==number)
            break;
        if(a[i]==0)
            cnt++;
        if(a[i]!=0 && a[i]+1<number)
        {
            int x=number-a[i]-1;
            cnt=cnt-x;
            break;
        }
    }
    return cnt;
    
}

int main() {
    int t;
    cin>>t;
    for(int i=0;i<t;i++)
    {
        
        
        cin>>n>>k;
        int cnt[k+1];
        
        for(int j=0;j<n;j++)
            cin>>a[j];
        
        a[0]=1;
        a[n-1]=k;
        
        int result=0;
        
        for(int j=0;j<n;j++)
        {
            if(a[j]!=0)
            {
            int getnum=get_cnt(a[j]);
            if(getnum>result)
                result=getnum;
            }
        }
        printf("#%d %d\n",i+1,result);
    }

    return 0;
}
